use "std.net";
use "std.fs";
use "std.string";
use "std.io"; // For print/debug

// Struct for In-Memory Data
struct SearchResult {
    title string;
    url string;
    content string;
    score int;
}

// Global Index
let memory_db = [];

// ---------------------------------------------------------
// JSON Parser (NDJSON Line Optimized)
// ---------------------------------------------------------

// Helper to extract value from "key": "VALUE" pattern
// Robust enough for the format generated by database.prox
func parse_json_value(json string, key string) string {
    let key_pattern = "\"" + key + "\": \"";
    let start_idx = json.index_of(key_pattern);
    
    if (start_idx == -1) { return ""; }
    
    let value_start = start_idx + key_pattern.length();
    let i = value_start;
    let value = "";
    
    // Scan until we hit a non-escaped quote
    while (i < json.length()) {
        let char = json.substring(i, i + 1);
        
        if (char == "\"" && json.substring(i - 1, i) != "\\") {
            // End of string
            break;
        }
        
        // Handle escaped chars if needed, or just Unescape later?
        // For search matching, we can keep raw distinct chars.
        // But let's unescape basic things for display if possible.
        // For now, raw extraction is safer for the "contains" check.
        value = value + char;
        i = i + 1;
    }
    
    return value;
}

func parse_ndjson_line(line string) SearchResult {
    let t = parse_json_value(line, "title");
    let u = parse_json_value(line, "url");
    let c = parse_json_value(line, "content");
    
    if (u == "") { return null; }
    
    // Initial score 0, recalculated during search
    return SearchResult { title: t, url: u, content: c, score: 0 };
}

// ---------------------------------------------------------
// Database Loading
// ---------------------------------------------------------

func load_index() {
    print("Loading index.json into RAM...");
    let file = fs.open("index.json", "r");
    
    if (file == null) {
        print("Error: index.json not found. Run crawler.prox first.");
        return;
    }
    
    let count = 0;
    while (true) {
        let line = file.read_line();
        if (line == null) { break; }
        
        if (line.length() > 5) {
            let item = parse_ndjson_line(line);
            if (item != null) {
                memory_db.push(item);
                count = count + 1;
            }
        }
    }
    file.close();
    print("Loaded " + count + " items into memory.");
}

// ---------------------------------------------------------
// Search Logic (With Ranking Boost)
// ---------------------------------------------------------

func search_index(query string) string {
    let results = [];
    let query_lower = query.to_lower();
    
    let i = 0;
    while (i < memory_db.length()) {
        let item = memory_db[i];
        
        // 1. Basic Matching
        let match_title = item.title.to_lower().contains(query_lower);
        let match_content = item.content.to_lower().contains(query_lower);
        
        if (match_title || match_content) {
            // 2. Ranking Algorithm
            item.score = 1; // Base Score
            
            // Boost for matches in Title
            if (match_title) { item.score = item.score + 10; }
            
            // SUPER BOOST for proxentix / proxpl
            if (item.url.contains("proxentix") || item.url.contains("proxpl")) {
                item.score = item.score + 1000;
            }
            
            results.push(item);
        }
        i = i + 1;
    }
    
    // 3. Sort Results by Score (Simple Bubble Sort for demonstration)
    // For 100 items this is fine. For millions, we'd need QuickSort.
    let x = 0;
    while (x < results.length()) {
        let y = 0;
        while (y < results.length() - x - 1) {
            if (results[y].score < results[y + 1].score) {
                // Swap
                let temp = results[y];
                results[y] = results[y + 1];
                results[y + 1] = temp;
            }
            y = y + 1;
        }
        x = x + 1;
    }
    
    // 4. Format Output Limit to Top 20
    let json_output = "{\"results\": [";
    let k = 0;
    let limit = 20;
    if (results.length() < 20) { limit = results.length(); }
    
    while (k < limit) {
        let r = results[k];
        if (k > 0) { json_output = json_output + ","; }
        
        // Hand-craft JSON output
        json_output = json_output + "{\"title\": \"" + r.title + "\", \"url\": \"" + r.url + "\", \"score\": " + r.score + "}";
        
        k = k + 1;
    }
    json_output = json_output + "]}";
    
    return json_output;
}

// ---------------------------------------------------------
// HTTP Server
// ---------------------------------------------------------

func handle_client(conn net.Connection) {
    let buffer = conn.read(2048);
    let raw = string(buffer);
    
    // Basic Parsing: GET /search?q=QUERY HTTP/1.1
    if (raw.starts_with("GET /search?q=")) {
        let start = 14;
        let end = raw.index_of(" ", start);
        if (end == -1) { end = raw.length(); }
        
        let q_enc = raw.substring(start, end);
        let q = q_enc.replace("%20", " "); // Decode spaces
        
        print("Searching for: " + q);
        
        let json_body = search_index(q);
        
        let response = "HTTP/1.1 200 OK\r\n" +
                       "Content-Type: application/json\r\n" +
                       "Access-Control-Allow-Origin: *\r\n" +
                       "Content-Length: " + json_body.length() + "\r\n" +
                       "\r\n" +
                       json_body;
        
        conn.write(response);
    } else {
        let msg = "Welcome to ProXplore API";
        conn.write("HTTP/1.1 200 OK\r\nContent-Length: " + msg.length() + "\r\n\r\n" + msg);
    }
    
    conn.close();
}

func main() {
    load_index(); 
    
    let port = 8080;
    print("Server ready on port " + port);
    
    let listener = net.listen("tcp", "0.0.0.0:" + port);
    if (listener == null) {
        print("Error checking binding port.");
        return;
    }
    
    while (true) {
        let conn = listener.accept();
        if (conn != null) {
            handle_client(conn);
        }
    }
}