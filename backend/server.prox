use "std.net";
use "std.io";
use "std.fs";
use "std.string";

// Struct used in RAM
struct SearchResult {
    title string;
    url string;
    content string;
}

// Global RAM Database (In-Memory Index)
let memory_db = [];

// Helper to manually parse a JSON line string
func parse_json_line(line string) SearchResult {
    // Extracts value between "key": "VALUE"
    func get_val(json string, key string) string {
        let pattern = "\"" + key + "\": \"";
        let start = json.index_of(pattern);
        if (start == -1) { return ""; }
        
        start = start + pattern.length();
        let end = json.index_of("\"", start); 
        // Note: A real parser handles escaped quotes here, this is basic
        if (end == -1) { return ""; }
        
        return json.substring(start, end);
    }
    
    let t = get_val(line, "title");
    let u = get_val(line, "url");
    let c = get_val(line, "content");
    
    if (u == "") { return null; }
    
    return SearchResult { title: t, url: u, content: c };
}

// 1. Load Database into RAM (Speed Optimization)
func load_database() void {
    print("Loading index.json into RAM...");
    let file = fs.open("index.json", "r");
    
    if (file == null) {
        print("Warning: index.json not found. Please run crawler first.");
        return;
    }
    
    let count = 0;
    while (true) {
        let line = file.read_line(); // Reads until newline
        if (line == null) { break; } // EOF
        
        if (line.length() > 5) {
            let item = parse_json_line(line);
            if (item != null) {
                memory_db.push(item);
                count = count + 1;
            }
        }
    }
    file.close();
    print("Database Loaded: " + count + " websites ready to search.");
}

// 2. Fast Search Function (No Disk I/O)
func search_memory(query string) string {
    let results = [];
    let query_lower = query.to_lower();
    let count = 0;
    let i = 0;
    
    // Linear scan through RAM
    while (i < memory_db.length()) {
        let item = memory_db[i];
        
        // Case-insensitive search in Title OR Content
        let match_title = item.title.to_lower().contains(query_lower);
        let match_content = item.content.to_lower().contains(query_lower);
        
        if (match_title || match_content) {
            results.push(item);
            count = count + 1;
        }
        
        if (count >= 20) { break; } // Limit results for speed/pagination
        i = i + 1;
    }
    
    return array_to_json(results);
}

// Convert Array -> JSON String
func array_to_json(arr array) string {
    let json = "{\"results\": [";
    let i = 0;
    while (i < arr.length()) {
        let item = arr[i];
        if (i > 0) { json = json + ","; }
        
        // Construct JSON object
        json = json + "{\"title\": \"" + item.title + "\", \"url\": \"" + item.url + "\", \"snippet\": \"" + item.content + "\"}";
        i = i + 1;
    }
    // Add fake metrics
    json = json + "], \"metrics\": {\"total_hits\": " + arr.length() + "}}";
    return json;
}

func handle_connection(conn net.Connection) void {
    let buffer = conn.read(1024);
    let request_str = string(buffer);
    
    // Parse: GET /search?q=XYZ
    if (request_str.starts_with("GET /search?q=")) {
        // Extract Query
        let start = 14; 
        let end = request_str.index_of(" ", start);
        if (end == -1) { end = request_str.length(); }
        
        let raw_q = request_str.substring(start, end);
        let query = raw_q.replace("%20", " "); // Handle spaces
        
        print("Search Query: " + query);
        
        let json_body = search_memory(query);
        
        // Standard HTTP Response headers with CORS
        let response = "HTTP/1.1 200 OK\r\n" +
                       "Content-Type: application/json\r\n" +
                       "Access-Control-Allow-Origin: *\r\n" + 
                       "Content-Length: " + json_body.length() + "\r\n" +
                       "\r\n" +
                       json_body;
        
        conn.write(response);
    } else {
        conn.write("HTTP/1.1 404 Not Found\r\n\r\n");
    }
    
    conn.close();
}

func main() {
    // Step 1: Load DB
    load_database();

    // Step 2: Start Server
    print("ProXplore Server running on http://localhost:8080");
    let listener = net.listen("tcp", "0.0.0.0:8080");
    
    if (listener == null) {
        print("Error: Port 8080 busy.");
        return;
    }

    while (true) {
        let conn = listener.accept();
        handle_connection(conn);
    }
}